/* @flow */

import type { TPkgJson } from '@knit/needle';
import type { TResults } from '@knit/depcheck';

export type TModules = Array<string>
type TFindDependencies = (dir: string) => Promise<TModules>;
type TFindModules = () => TModules
type TFindMissingDependencies = (u: TModules, m: TModules) => TModules;
type TFindModifiedSince = (m: TModules, tag: string) => TModules;
type TFindAllMissingDependencies = (m: TModules) => Promise<TModules>;
type TFindAllUnusedDependencies = (m: TModules) => Promise<TModules>;
type TMakeDependencyMap = (m: TModules) => Promise<{[k:string]: TModules}>;
type TResolveCascadingUpdates = (m: TModules, mp: {[k:string]: TModules}, total: TModules) => TModules;
type TFindUpdatedSince = (m: TModules, tag: string) => Promise<TModules>;
type TGetDependencyVersion = (d: string, m: TModules, u: TModules) => string;
type TUpdateModulePkg = (m: TPkgJson, ms: TModules, used: TModules, updated: TModules, version: ?string) => TPkgJson;
type TUpdateModulePkgBrowser = (p: TPkgJson) => TPkgJson;
type TGetModuleName = (m: string) => string;
type TIsScoped = (m: string) => boolean;
type TReadPkg = (d: string) => ?TPkgJson;

declare module.exports: {
  getModuleName: TGetModuleName,
  isScoped: TIsScoped,
  readPkg: TReadPkg;
  findDependencies: TFindDependencies,
  findModules: TFindModules,
  findPublicModules: TFindModules,
  makeDependencyMap: TMakeDependencyMap,
  findAllMissingDependencies: TFindAllMissingDependencies,
  findAllUnusedDependencies: TFindAllUnusedDependencies,
  findModifiedSince: TFindModifiedSince,
  findUpdatedSince: TFindUpdatedSince,
  findMissingDependencies: TFindMissingDependencies,
  resolveCascadingUpdates: TResolveCascadingUpdates,
  getDependencyVersion: TGetDependencyVersion,
  updateModulePkg: TUpdateModulePkg,
  updateModulePkgBrowser: TUpdateModulePkgBrowser,
};
