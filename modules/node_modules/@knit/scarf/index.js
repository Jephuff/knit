/* @flow weak */

const path = require('path');
const execa = require('execa');
const chalk = require('chalk');
const fs = require('graceful-fs');

const needle = require('@knit/needle');
const depchek = require('@knit/depcheck');

const findDependencies = async function(dir) {
  try {
    const res = await depchek(path.join(needle.paths.modules, dir));
    return Object.keys(res.using);
  } catch (err) {
    catchErrors(err);
    return []
  }
};

const safeFindPkg = (dir) => {
  try {
    // $FlowIgnore
    return require(path.join(dir, 'package.json'));
  } catch (err) {
    return null;
  }
};

const findModules = () => {
  try {
    return fs.readdirSync(needle.paths.modules).filter(safeFindPkg);
  } catch (err) {
    throw new Error('Modules directory could not be read. Make sure your modules are in `modules/node_modules`')
  }
};

const findMissingDependencies = function() {
  const modules = findModules();

  return modules.reduce(async function (acc, m) {
    const installed = Object.keys(needle.pkg.dependencies || {});
    const used = await findDependencies(m);
    return Object.assign({}, acc, {
      [m]: used.filter(d => !installed.includes(d)),
    });
  }, {});
};

const findModifiedSince = (modules, tag) => {
  const output = execa.sync('git', ['diff', '--dirstat=files,0', tag, '--', needle.paths.modulesStub]);
  const lines = output.stdout.split('\n');

  const modified = lines.map(l => {
    const [scope, name] = l.split(needle.paths.modulesStub)[1].split('/');
    return (scope.indexOf('@') !== -1) ? [scope, name].join('/') : name;
  }).reduce(
    (acc, m) => acc.includes(m) ? acc : acc.concat(m), []
  ).filter(
    m => modules.includes(m)
  );

  return modified;
};

const makeDependencyMap = function(modules) {
  return modules.reduce(function (acc, m) {
    return Object.assign({}, acc, {
      [m]: findDependencies(m),
    });
  }, {});
};

const resolveDependencies = (modules, mapping, modified) => {
    const next = modules.reduce((acc, module) => {
      if (acc.includes(module)) return acc;
      const deps = mapping[module] || [];

      if (deps.some(d => acc.includes(d))) {
        return acc.concat(module);
      }

      return acc;
    }, modified);

    if (next.length !== modified.length) {
      return resolveDependencies(modules, mapping, next)
    }

    return modified;
}

const findUpdatedSince = function(tag) {
  // all modules
  const modules = findModules();
  // map of {module: [module dependencies]}
  const dependencyMap = makeDependencyMap(modules);
  // files modified according to git
  const modifiedModules = findModifiedSince(modules, tag);

  return resolveDependencies(modules, dependencyMap, modifiedModules);
};

const getDependencyVersion = (dep, modules, updated) => {
  if (needle.pkg.dependencies && needle.pkg.dependencies[dep]) {
    return needle.pkg.dependencies[dep]
  } else if (updated.includes(dep)) {
    return needle.pkg.version;
  } else if (modules.includes(dep)) {
    const pkg = safeFindPkg(path.join(needle.paths.modules, dep));
    if (pkg && pkg.version) {
      return pkg.version;
    }
  }

  throw new Error(`Missing dependency: ${dep}`);
};

const updateModulePkg = (pkg, modules, used, updated) => {
  const projectPkg = needle.pkg;
  return (
    Object.assign({},
      {
        main: 'lib/index.js',
        version: projectPkg.version,
        files: ['*.md', 'docs', 'es', 'lib', 'umd'],
        repository: projectPkg.repository,
        engines: projectPkg.engines,
        author: projectPkg.author,
        homepage: projectPkg.homepage,
        license: projectPkg.license,
        bugs: projectPkg.bugs,
        tags: projectPkg.tags,
        keywords: projectPkg.keywords,
        dependencies: used.filter(d => (
          !Object.keys(projectPkg.peerDependencies || {}).includes(d)
        )).reduce((acc, d) => (
          Object.assign(acc, {
            [d]: getDependencyVersion(d, modules, updated),
          })
        ), {}),
        peerDependencies: used.filter(d => (
          Object.keys(projectPkg.peerDependencies || {}).includes(d)
        )).reduce((acc, d) => (
          Object.assign(acc, {
            [d]: parseInt((projectPkg.dependencies || {})[d], 10).toString(),
          })
        ), {}),
      },
      pkg
    )
  );
}

const updateModulePkgBrowser = (pkg) => (
  Object.assign({},
    pkg,
    {
      'jsnext:main': 'es6/index.js',
      browser: `umd/index.${needle.env['process.env'].NODE_ENV === 'production' ? 'min.' : ''}js`,
    }
  )
)

const catchErrors = (err) => {
  if (err.cmd) {
    console.log(chalk.bgBlue.white(' COMMAND '));
    console.log(chalk.white(err.cmd));
    console.log();
    console.log(chalk.bgRed.white(' ERROR '));
    if (err.stderr) {
      console.log(chalk.white(err.stderr.split('\n    at')[0]));
    }
    console.log(chalk.white(err.stdout.split('\n    at')[0]));
  } else {
    const PrettyError = require('pretty-error');

    const pe = new PrettyError();
    console.log();
    console.log(pe.render(err));
  }
};

console.log(findMissingDependencies());

module.exports = {
  findDependencies,
  safeFindPkg,
  findModules,
  findModifiedSince,
  findUpdatedSince,
  resolveDependencies,
  catchErrors,
};
