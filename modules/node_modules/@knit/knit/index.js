/* @flow weak */

const path = require('path');
const execa = require('execa');
const chalk = require('chalk');
const fs = require('graceful-fs');

const needle = require('@knit/needle');
const depchek = require('@knit/depcheck');

const utils = require('./lib/utils');

exports.findDependencies = (dir) => (
   depchek(path.join(needle.paths.modules, dir))
    .then(res => Object.keys(res.using))
    .then(using => {
      const pkg = utils.safeFindPkg(dir);
      return using.concat(Object.keys((pkg || {}).dependencies || {}));
    })
);

exports.findMissingDependencies = (using, modules) => {
  const installed = Object.keys(needle.pkg.dependencies || {});

  return using.filter(m => !installed.includes(m) && !modules.includes(m));
};

exports.findUnusedDependencies = (using, modules) => {
  const installed = Object.keys(needle.pkg.dependencies || {});

  return installed.filter(m => !using.includes(m) && !modules.includes(m));
};

exports.findInternalDependencies = (using, modules) =>
   using.filter(m => (
    modules.includes(m)
  ))
;

exports.findModules = () => {
  try {
    return fs.readdirSync(needle.paths.modules)
      .reduce((acc, d) => {
        if (utils.isScoped(d)) {
          return acc.concat(fs.readdirSync(path.join(needle.paths.modules, d)).map(dir => path.join(d, dir)));
        }

        return acc.concat(d);
      }, []).filter(m => {
        const pkg = utils.safeFindPkg(m);
        return pkg && !pkg.private;
      });
  } catch (err) {
    throw `Modules directory could not be read. Make sure your modules are in \`${needle.paths.modulesStub}\``;
  }
};

exports.findModifiedSince = (modules, tag) => {
  const output = execa.sync('git', ['diff', '--dirstat=files,0', tag, '--', needle.paths.modulesStub]);
  const lines = (output.stdout || '').split('\n');

  const modified = lines.map(l => {
    const [scope, name] = l.split(`${needle.paths.modulesStub}/`)[1].split('/');
    return utils.isScoped(scope) ? [scope, name].join('/') : scope;
  }).filter(
    Boolean
  ).reduce(
    (acc, m) =>
       acc.includes(m) ? acc : acc.concat(m)

  , []).filter(
    m => modules.includes(m)
  );

  return modified;
};

exports.findAllMissingDependencies = function (modules) {
  return modules.reduce((acc, m) =>
     Promise.all([acc, exports.findDependencies(m)]).then(
      vals =>
         vals[0].concat(exports.findMissingDependencies(vals[1], modules))

    ).then(ms => (
      ms.reduce((a, m) => (
        a.includes(m) ? a : a.concat(m)
      ), [])
    ))
  , []);
};

exports.findAllDependencies = function (modules) {
  return modules.reduce((acc, m) =>
     Promise.all([acc, exports.findDependencies(m)]).then(
      vals =>
         vals[0].concat(vals[1], modules)

    ).then(ms => (
      ms.reduce((a, m) => (
        a.includes(m) ? a : a.concat(m)
      ), [])
    ))
  , []);
};

exports.findAllUnusedDependencies = function (modules) {
  const installed = Object.keys(needle.pkg.dependencies || {});

  return exports.findAllDependencies(modules).then(using => (
    installed.filter(i => !using.includes(i) && !modules.includes(i))
  ));
};

exports.makeDependencyMap = function (modules) {
  return modules.reduce((acc, m) =>
     Promise.all([acc, exports.findDependencies(m)]).then(
      vals => Object.assign({}, vals[0], {
        [m]: vals[1],
      })
    )
  , {});
};

exports.resolveCascadingUpdates = (modules, mapping, modified) => {
  const next = modules.reduce((acc, module) => {
    if (acc.includes(module)) return acc;
    const deps = mapping[module] || [];

    if (deps.some(d => acc.includes(d))) {
      return acc.concat(module);
    }

    return acc;
  }, modified);

  if (next.length !== modified.length) {
    return exports.resolveCascadingUpdates(modules, mapping, next);
  }

  return modified;
};

exports.findUpdatedSince = function (modules, tag) {
  // files modified according to git
  const modifiedModules = exports.findModifiedSince(modules, tag);
  // map of {module: [module dependencies]}
  return exports.makeDependencyMap(modules).then(dependencyMap =>
     exports.resolveCascadingUpdates(modules, dependencyMap, modifiedModules)
  );
};

exports.getDependencyVersion = (dep, modules, updated) => {
  if (needle.pkg.dependencies && needle.pkg.dependencies[dep]) {
    return needle.pkg.dependencies[dep];
  } else if (updated.includes(dep)) {
    return needle.pkg.version;
  } else if (modules.includes(dep)) {
    const pkg = utils.safeFindPkg(dep);
    if (pkg && pkg.version) {
      return pkg.version;
    }
  }

  throw `Missing dependency: ${dep}`;
};

exports.updateModulePkg = (pkg, modules, used, updated) => {
  const projectPkg = needle.pkg;
  return (
    Object.assign({},
      {
        homepage: projectPkg.homepage,
        license: projectPkg.license,
        bugs: projectPkg.bugs,
        tags: projectPkg.tags,
        keywords: projectPkg.keywords,
      },
      pkg,
      {
        main: 'index.js',
        version: projectPkg.version,
        private: false,
        repository: projectPkg.repository,
        engines: projectPkg.engines,
        author: projectPkg.author,
        dependencies: used.concat(Object.keys(pkg.dependencies || {})).filter(d => (
          !Object.keys(projectPkg.peerDependencies || {}).includes(d)
        )).reduce((acc, d) => (
          Object.assign(acc, {
            [d]: exports.getDependencyVersion(d, modules, updated),
          })
        ), {}),
        peerDependencies: used.filter(d => (
          Object.keys(projectPkg.peerDependencies || {}).includes(d)
        )).reduce((acc, d) => (
          Object.assign(acc, {
            [d]: parseInt((projectPkg.dependencies || {})[d], 10).toString(),
          })
        ), {}),
      }
    )
  );
};

exports.updateModulePkgBrowser = (pkg) => (
  Object.assign({},
    pkg,
    {
      main: path.join(needle.paths.distStub, needle.paths.libStub, 'index.js'),
      'jsnext:main': path.join(needle.paths.distStub, needle.paths.es6Stub, 'index.js'),
      browser: path.join(needle.paths.distStub, needle.paths.umdStub, 'index.min.js'),
    }
  )
);
