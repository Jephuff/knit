#!/usr/bin/env node

const Listr = require('listr');
const chalk = require('chalk');

const knit = require('@knit/knit-core');
const log = require('@knit/mittens-logger');
const errors = require('@knit/mittens-nice-errors');
const tasks = require('@knit/mittens-common-tasks');

module.exports = (argv) => {
  new Listr([
    ...tasks.modules,
    ...tasks.packages,
    ...(argv.updated ? tasks.updated : []),
  ], {
    renderer: log.getRenderer(),
  }).run().then(ctx => {
    const publicModules = (ctx || {}).modules || [];
    const modules = argv.modules.length
      ? argv.modules
      : argv.updated
        ? ctx.updated
        : publicModules;
    const fMs = modules.filter(m => publicModules.includes(m));
    const nfMs = modules.filter(m => !publicModules.includes(m));

    console.log();
    log.info(chalk.white(`showing dependencies for ${fMs.length} ${argv.updated && 'updated'} modules`));
    console.log();
    Promise.all(fMs.map(m => knit.findDependencies(m).then(using => {
      const missing = knit.findMissingDependencies(using, publicModules);
      const internal = knit.findMissingDependencies(using, publicModules);

      console.log(
        chalk.white(`- ${m}`),
        chalk.white(`(${ctx.pkgs[m].version})`),
        chalk.grey([
          `[${using.length} dependencies`,
          missing.length ? `, ${chalk.red(`${missing.length} missing`)}]` : ']',
        ].join(''))
      );

      if (argv.dependencies) {
        using.length && log.subtree(using.join(' '));
        if (missing.length > 0) {
          log.missing();
          log.subtree(chalk.white(missing.join(' ')));
        }
        console.log();
      }
    }).catch(errors.catchErrors))).then(() => {
      if (nfMs.length) {
        console.log();
        log.warning(chalk.white('could not find the following modules'));
        log.subtree(nfMs.join(' '));
      }
    });
  }).catch(errors.catchErrors);
};
